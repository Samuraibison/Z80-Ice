Z80 ICE V1.0 Problems
=====================


Electrical
----------

 1. nMREQ shouldn't be gated with nSYSSIG in U10B because nMREQ needs to remain active with
    nRFSH to refresh DRAMs in the idle state when nSYSSIG is high, see mod 1.

 2. Interrupt enable signal needs to be generated by the CPLD because of a timing hazard
    (see TODO in cpld.c).  See mod 2.

 3. The BUSY LED connected to PGD stops the PIC debugger working.  Could connect the LED to
    GND instead so it becomes a pull-down.

 4. Signals from the ICE supply parasitic power to the target.  U7-U9 outputs need to be
    tri-stated if there is no target power.  Also change RP1 to 100K, see mod 3.

 5. SD0-SD2 need 4k7 pull-downs or the signal stays high when the SRAM stops driving the bus.
    Check why that is a problem (it was needed on the breadboard build).  Done a software
    workaround which seems to work.  I now think this is a red herring - the prototype would
    work without the pull down if we used the latest CPLD design.

 6. It doesn't work at 20MHz (only 18MHz with a short cable).  Observing signals on the
    system Z80 socket, when running at 16MHz, the clock arrives at the ICE Z80 clock pin
    with very little delay although the edges are quite slow.  Then the control signals
    such as nM1, nMREQ, nRD etc. arrive at the system socket with about half a clock cycle
    delay (31ns).  Some of the delay is in the Z80, almost none in the gates, about 12ns in
    the HC244 buffer and none in the 47R resistor.  We can improve the timing by about 6ns
    by switching to AC244 buffers and square up the clock by reducing the 47R on the adaptor
    board to 22R?  See mod 4.


Mechanical
----------

 1. USB conn should be 0.6mm farther to the right to be flush with case external face.

 2. J2 is designed to go on the edge of the PCB and it has a ridge which extends beyond the
    PCB edge.  As a result it doesn't fit flush to the PCB and has to be fitted at an angle
    or raised manually to solder it flat (but raised).  Maybe cut the end off the PCB so it
    fits on the end and get rid of 2 mounting holes or use the same connector as the Z80
    socket adaptor.


Improvements for next board
---------------------------

 1. Use U10B to replace U12A/B.  U12 is no longer required after parasitic power fix
    below but 2 NANDs and an inverter are added.

 2. To fix electrical problem 4 (parasitic power)...
      a) In software, if ZVCC is too low or there is no clock coming from the system,
         hold the Z80 and CPLD in reset to stop parasitic power from the data bus.
      b) Replace U12C with a NAND gate with nBACK and nZ80RST as inputs.  Connect the
         output to U7 & U8 (U9A pin 1 no longer driven from this gate).
      c) Use another NAND gate to drive U9A pin 1 with inputs connected to nBACK and
         nRSTOUT from the PIC.
      d) Invert nRSTOUT from the PIC and connect it to U9B pin 19.
      e) Swap RP1 for a 100K version.

 3. Decoupling cap grounds could be shorter/better e.g. the SRAM


Manufacturing problems
----------------------

 1. 



Future ideas
------------

 1. Possibly drive nCTS on the FTDI chip to force it to send the buffered data to the PC.
    We'd need to find a PIC pin/signal we can re-use.

 2. Power & busy LEDs on outside of box?



PCB Modifications
-----------------

 1. Lift U10 pin 5 and connect pin 5 to pin 4.

 2. Cut track on solder side (blue) from U1 pin 20 to U5 pin 5 (nIORQ).
    Cut track on component side (red) from U3 pin 9 to U11 before it gets to the via under U1 (nINTEN).
    On the solder side (blue), connect the nINTEN via near U1 pins 15 & 16 to the U5 pin 5 via (nIORQ) with a wire.
    On the component side (red), connect U5 pin 38 to U3 pin 9 with a wire - now called INTBLK.

 3. Replaced RP1 with 100K version.

 4. Replaced U7-U9 with 74AC244.


Mod 2 corner case
-----------------

If an interrupt is recognised during the instruction before a breakpoint, the Z80 starts an interrupt
acknowledge cycle which consists of nM1 and nIORQ going low.  Unfortunately we have to recognise the
breakpoint on the nM1 half a cycle before nMREQ so we can gate off nRD to the system in time to stop
a valid memory cycle for the system.  This means that the breakpoint is recognised due to nM1 going
low on an interrupt acknowledge cycle and the PC ends up on the interrupt vector.

This is guaranteed to happen whenever the interrupts are enabled by an EI RET sequence if there is a
breakpoint on the return address.  That's why the Z80 version of chip_enable_interrupts() has a NOP.

